== Component usage

This chapter details how to use each of the components included in Snowdrop. 

=== VFS-enabled Application Contexts

[icon="./images/community/asciidoc/note.png"]
[NOTE]
====
From Spring 3.0 onward, the ApplicationContext implementations shipped with the Spring framework are VFS-compatible. The components described in this section are included with Snowdrop to provide backwards compatibility, but are not necessarily required. 
====

The _snowdrop-vfs.jar_ library supports resource scanning in the JBoss Virtual File System (VFS). It must be included in Spring-based applications that use classpath and resource scanning. 

When the Spring framework performs resource scanning, it assumes that resources are either from a directory or a packaged JAR, and treats any URLs it encounters accordingly. 

This assumption is not correct for the JBoss VFS, so Snowdrop provides a different underlying resource resolution mechanism by amending the functionality of the PathMatchingResourcePatternResolver. 

This is done by using one of two ApplicationContext implementations provided by _snowdrop-vfs.jar_: 

org.jboss.spring.vfs.context.VFSClassPathXmlApplicationContext::  Replaces the Spring  org.springframework.context.support.ClassPathXmlApplicationContext. 

org.jboss.spring.vfs.context.VFSXmlWebApplicationContext::  Replaces the Spring org.springframework.web.context.support.XmlWebApplicationContext. 

In many cases, the  VFSClassPathXmlApplicationContext is instantiated on its own, using something like: 

[source, Java]
----
ApplicationContext context = 
new VFSClassPathXmlApplicationContext("classpath:/context-definition-file.xml");
----

The XmlWebApplicationContext is not  instantiated directly. Instead, it is bootstrapped by either the  ContextLoaderListener or the  DispatcherServlet. Both classes have  configuration options that allow users to replace the default application context type with a custom application context type. 

To change the type of application context created by the ContextLoaderListener, add the  contextClass parameter as shown in the following example code: 

[source, xml]
----
<programlisting language="XML" format="linespecific"><context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>classpath*:spring-contexts/*.xml</param-value>
</context-param>
<emphasis role="bold"><context-param>
  <param-name>contextClass</param-name>
  <param-value>
    org.jboss.spring.vfs.context.VFSXmlWebApplicationContext
  </param-value>
</context-param></emphasis>
<listener>
  <listener-class>
    org.springframework.web.context.ContextLoaderListener
  </listener-class>
</listener></programlisting>
----

To change the type of application context created by the DispatcherServlet, use the same  contextClass parameter on the  DispatcherServlet definition as shown: 

[source, xml]
----
<servlet>
  <servlet-name>spring-mvc-servlet</servlet-name>
  <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  <init-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/mvc-config.xml</param-value>
  </init-param><emphasis role="bold">  
  <init-param>
  <param-name>contextClass</param-name>
    <param-value>
      org.jboss.spring.vfs.context.VFSXmlWebApplicationContext
    </param-value>
  </init-param>
</emphasis></servlet></programlisting>
----

[icon="./images/community/asciidoc/important.png"]
IMPORTANT: ZipException: If you encounter the ZipException when attempting to start the application, you need to replace the default ApplicationContext with one of the VFS-enabled implementations. 
----
Caused by: java.util.zip.ZipException: error in opening zip file
...
at org.springframework.core.io.support.PathMatchingResourcePatternResolver
.doFindPathMatchingJarResources(PathMatchingResourcePatternResolver.java:448)
----


=== The JBoss custom namespace

Starting with version 1.2, Snowdrop includes a custom Spring namespace for JBoss AS. The goals of this custom namespace is to simplify the development of Spring applications that run on JBoss, by reducing the amount of proprietary code and improving portability.

The amount of proprietary code is reduced because of replacing bean definitions that include references to specific JBoss classes with namespace-based constructs. All the knowledge about the proprietary classes is encapsulated in the namespace handlers. 

The applications are more portable because certain proprietary classes may change when upgrading to a different version of the application server. In such cases, the runtime will be detected automatically by Snowdrop which will set up beans using the classes that are appropriate for that specific runtime. 

The custom namespace can be set up as follows:


[source, XML]
----
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:jboss="http://www.jboss.org/schema/spring"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.jboss.org/schema/snowdrop http://www.jboss.org/schema/snowdrop/snowdrop.xsd">
----

==== Accessing the default JBoss MBean Server

The default MBean server of JBoss AS can be accessed as follows:
[source, XML]
----
<jboss:mbean-server/>
----

The bean will be installed with the default id 'mbeanServer'. If necessary, developers can specify a different bean name:

[source, XML]
----
<jboss:mbean-server id="customName"/>
----

==== JCA/JMS support beans 

Spring JMS message listeners (including message-driven POJOs) can use a JCA-based MessageListenerContainer. The configuration of a JCA-based listener container in Spring requires the setup of a number of beans based on application-server specific classes. Using the JBoss custom namespace, the ResourceAdapter and ActivationSpec configuration can be set up as follows:


[source, XML]
----
    <jboss:activation-spec-factory id="activationSpecFactory" subscriptionName="jca-example" useDLQ="false"/>

    <jboss:resource-adapter id="resourceAdapter"/>

----

which can be further used in a JCA message listener configuration:


[source, XML]
----
<jms:jca-listener-container resource-adapter="resourceAdapter" acknowledge="auto"
                               activation-spec-factory="activationSpecFactory">
       <jms:listener destination="/someDestination" ref="messageDrivenPojo"
                     method="pojoHandlerMethod"/>
</jms:jca-listener-container>
----

=== Load-time weaving

[icon="./images/community/asciidoc/note.png"]
[NOTE]
====
From Spring 3.0 onward, load-time weaving on JBoss AS 5 and JBoss AS 6 is supported out of the box. However, on JBoss AS7 it is necessary to use the load-time weaver provided by Snowdrop. The component described in this section should be used with Spring 2.5 on any of the servers or when using Spring 2.5 and Spring 3.0 with JBoss AS7. In other cases, it is optional, but can be used to facilitate backwards compatibility. 
====

Load-time weaving support is provided by the  _snowdrop-weaving.jar_ library. 

To perform load-time weaving for the application classes in Spring (either for using load-time support for AspectJ or for JPA support), the Spring framework needs to install its own transformers in the classloader. For JBoss Enterprise Application Platform, JBoss Enterprise Web Platform and JBoss Enterprise Web Server,  a classloader-specific LoadTimeWeaver is necessary. 

Define the JBossLoadTimeWeaver in the Spring application context as shown here: 

[source, Java]
----
<context:load-time-weaver weaver-class="org.jboss.instrument.classloading.JBossLoadTimeWeaver"/>
----

=== The Spring Deployer

The Spring deployer allows you to bootstrap a Spring application context, bind it in JNDI, and use it to provide Spring-configured business object instances. 

==== JBoss + Spring + EJB 3.0 Integration

Snowdrop contains a JBoss deployer that supports Spring packaging in JBoss AS. This means that it is possible to create JAR archives with a _META-INF/jboss-spring.xml_ file to have your Spring bean factories deploy automatically. 

EJB 3.0 integration is also supported. You can deploy Spring archives and inject beans created in these deployments directly into an EJB by using the @Spring annotation. 

==== Spring Deployer Installation

===== Installation on JBoss AS 5 and JBoss AS 6

To install the Spring deployer, unzip the deployer archive in the _$$$JBOSS_HOME/server/$PROFILE/deployers$$_ directory of your JBoss Application Server installation. 

The Snowdrop Spring deployer requires the inclusion of the Spring libraries. If you are installing a version without dependencies or you want to include your own Spring version, you must ensure that you are including one of the following sets of Spring libraries in the _$$$JBOSS_HOME/server/$PROFILE/deployers/spring.deployer$$_ folder. 

Please include at least the following jars from either the Spring 2.5.6.SEC03 or Spring 3.0.6.RELEASE distribution: 


* spring-beans.jar (or org.springframework.beans.jar)
* spring-context.jar (org.springframework.context.jar)
* spring-core.jar (or org.springframework.core.jar)
* spring-web.jar (or org.springframework.web.jar)

===== Installation on JBoss AS 7

To install the Snowdrop Deployment subsystem, unzip the _jboss-spring-subsystem-as7.zip_ file. Create the subsystem and Spring modules in JBoss AS7 by copying  the contents of the _module-deployer_ folder and one of the _module-spring-2.5_ or _spring-3_ folders in the _$$$JBOSS_HOME/modules$$_ directory of your JBoss Application Server installation. 

The above step will create two modules inside JBoss AS7: 

org.jboss.snowdrop:main:: The module that contains the JBoss AS7 subsystem proper

org.springframework.spring:snowdrop:: A module that contains the Spring JARs that are required by Snowdrop. It can contain Spring 2.5 or Spring 3 JARs, dependending the which of the two modules has been copied in the step above. Users may add other JARs to the module, case in which they need to adjust the _module.xml_ file accordingly. It is a dependency of org.jboss.snowdrop:main 

If you are using the distribution without dependencies, or you wish to create your own version of the Spring module, then create a _$$$JBOSS_HOME/modules/org/springframework/spring/main$$_ directory and copy one of the two _module.xml_ files (from either the _module-spring-2.5_ or the _module-spring-3_ directory of the distribution and copy one of the following sets of files from the corresponding Spring distribution (either Spring 2.5.6.SEC03 or Spring 3.0.6.RELEASE). 

For Spring 2.5:

* aspectjrt.jar
* aspectjweaver.jar
* aopalliance.jar
* spring-aop.jar
* spring-beans.jar
* spring-core.jar
* spring-context.jar
* spring-context-support.jar
* spring-web.jarFor Spring 3:


* aspectjrt.jar
* aspectjweaver.jar
* aopalliance.jar
* spring-aop.jar
* spring-asm.jar
* spring-beans.jar
* spring-core.jar
* spring-expression.jar
* spring-context.jar
* spring-context-support.jar
* spring-web.jar

The final step in the installation is to change _$$$JBOSS_HOME/standalone/configuration/standalone.xml$$_ by including +<extension module="org.jboss.snowdrop"/>+ inside the +<extensions>+ element, as well as including +<subsystem xmlns="urn:jboss:domain:snowdrop:1.0"/>+ inside the +<profile>+ element.

==== Spring deployments

You can create Spring deployments that work similarly to JARs, EARs, and WARs with the JBoss Spring deployer. Spring JARs are created with the following  structure: 

----
my-app.spring/
  org/
    acme/
      MyBean.class
      MyBean2.class
  META-INF/
    jboss-spring.xml
----

_my-app.spring_ is a JAR that contains classes. A _jboss-spring.xml_ file exists in the  _META-INF_ directory of the JAR. By default, the JBoss Spring deployer registers the bean factory defined in  _jboss-spring.xml_ into JNDI in a non-serialized form. The default JNDI name is the short name of the deployment file — in this case, +my-app+. 

You can also place JAR libraries under _$$$JBOSS_HOME/server/$PROFILE/lib$$_ and add an XML file of the form +<name>-spring.xml+, for example, _my-app-spring.xml_, into the _deploy_ directory of your JBoss Enterprise Application Platform or JBoss Enterprise Web Platform installation. The default JNDI name will be the short name of the XML file; in this case, +my-app+. 

==== Deployment

Once you have created a _.spring_ or a _-spring.xml_ file, copy it into the _deploy_ directory of your JBoss AS installation to deploy it into the JBoss runtime. You can also embed these deployments in an EAR, EJB-SAR, SAR, and so on, since JBoss AS supports nested archives.

==== Defining the JNDI name

You can specify the JNDI name explicitly by putting it in the description element of the Spring XML. 


[source, XML]
----
<beans>
  <description>BeanFactory=(MyApp)</description>
  ...
  <bean id="springBean" class="example.SpringBean"/>
</beans>
----

+MyApp+ will be used as the JNDI name in this example. 

==== Parent Bean factories

Sometimes you want your deployed Spring bean factory to be able to reference beans deployed in another Spring deployment. You can do this by declaring a parent bean factory in the description element in the Spring XML, like so: 


[source, XML]
----
<beans>
<description>BeanFactory=(AnotherApp) ParentBeanFactory=(MyApp)</description>
...
</beans>
----

==== Injection into EJBs

Once an ApplicationContext has been successfully bootstrapped, the Spring beans defined in it can be used for injection into EJBs. To do this, the EJBs must be intercepted with the SpringLifecycleInterceptor, as in the following example: 

[source, Java]
----
@Stateless
@Interceptors(SpringLifecycleInterceptor.class)
public class InjectedEjbImpl implements InjectedEjb
{
 @Spring(bean = "springBean", jndiName = "MyApp")
 private SpringBean springBean;

 /* rest of the class definition ommitted */
}
----

In this example, the EJB InjectedEjbImpl will be  injected with the bean named +springBean+, which is defined in the ApplicationContext.